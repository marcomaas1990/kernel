<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Byte-order-aware numeric types."><title>endian_num - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="endian_num" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.0-nightly (ada5e2c7b 2024-05-31)" data-channel="nightly" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../endian_num/index.html">endian_num</a><span class="version">0.1.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">endian_num</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/endian_num/lib.rs.html#1-1502">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Byte-order-aware numeric types.</p>
<p>This crate provides the <a href="struct.Be.html" title="struct endian_num::Be"><code>Be</code></a> (big-endian) and <a href="struct.Le.html" title="struct endian_num::Le"><code>Le</code></a> (little-endian) byte-order-aware numeric types.</p>
<p>Unlike the popular <a href="https://docs.rs/byteorder"><code>byteorder</code></a> crate, which focuses on the action of encoding and decoding numbers to and from byte streams, this crate focuses on the state of numbers.
This is useful to create structs that contain fields of a specific endianness for interoperability, such as in virtio.
In comparison to other crates that focus on state, this crate closely follows naming conventions from <a href="https://doc.rust-lang.org/nightly/core/num/index.html" title="mod core::num"><code>core::num</code></a>, has rich functionality, and extensive documentation of each method.</p>
<p>The core API looks <em>roughly</em> like this (correspondingly for <code>Be</code>):</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[repr(transparent)]
</span><span class="kw">pub struct</span>&lt;T&gt; Le(<span class="kw">pub </span>T);

<span class="kw">impl </span>Le&lt;T: Integer&gt; {
    <span class="kw">pub const fn </span>from_ne(n: T) -&gt; <span class="self">Self</span>;
    <span class="kw">pub const fn </span>from_be(n: Be&lt;T&gt;) -&gt; <span class="self">Self</span>;

    <span class="kw">pub const fn </span>to_ne(<span class="self">self</span>) -&gt; T;
    <span class="kw">pub const fn </span>to_be(<span class="self">self</span>) -&gt; Be&lt;T&gt;;

    <span class="kw">pub const fn </span>to_be_bytes(<span class="self">self</span>) -&gt; [u8; mem::size_of::&lt;<span class="self">Self</span>&gt;()];
    <span class="kw">pub const fn </span>to_le_bytes(<span class="self">self</span>) -&gt; [u8; mem::size_of::&lt;<span class="self">Self</span>&gt;()];
    <span class="kw">pub const fn </span>to_ne_bytes(<span class="self">self</span>) -&gt; [u8; mem::size_of::&lt;<span class="self">Self</span>&gt;()];

    <span class="kw">pub const fn </span>from_be_bytes(bytes: [u8; mem::size_of::&lt;<span class="self">Self</span>&gt;()]) -&gt; <span class="self">Self</span>;
    <span class="kw">pub const fn </span>from_le_bytes(bytes: [u8; mem::size_of::&lt;<span class="self">Self</span>&gt;()]) -&gt; <span class="self">Self</span>;
    <span class="kw">pub const fn </span>from_ne_bytes(bytes: [u8; mem::size_of::&lt;<span class="self">Self</span>&gt;()]) -&gt; <span class="self">Self</span>;
}</code></pre></div>
<p>The types also implement appropriate traits from <a href="https://doc.rust-lang.org/nightly/core/cmp/index.html" title="mod core::cmp"><code>core::cmp</code></a>, <a href="https://doc.rust-lang.org/nightly/core/convert/index.html" title="mod core::convert"><code>core::convert</code></a>, <a href="https://doc.rust-lang.org/nightly/core/fmt/index.html" title="mod core::fmt"><code>core::fmt</code></a>, and <a href="https://doc.rust-lang.org/nightly/core/ops/index.html" title="mod core::ops"><code>core::ops</code></a> and provide additional helper methods for computations.</p>
<p>In addition to widening and byte-reordering <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From"><code>From</code></a> implementations, the endian number types implement conversions to and from arrays of smaller number types of the same ordering.
This is useful in situations, where a larger field has to be treated as multiple smaller field.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>endian_num::Le;

<span class="kw">let </span>a = Le::&lt;u32&gt;::from_ne(<span class="number">0x1A</span>);
<span class="kw">let </span>b = Le::&lt;u32&gt;::from_ne(<span class="number">0x2B00</span>);

<span class="macro">assert_eq!</span>((a + b).to_le_bytes(), [<span class="number">0x1A</span>, <span class="number">0x2B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>]);</code></pre></div>
<h2 id="optional-features"><a class="doc-anchor" href="#optional-features">§</a>Optional features</h2>
<p>This crate has the following optional features:</p>
<ul>
<li><a href="../bitflags/index.html" title="mod bitflags"><code>bitflags</code></a> — <code>Be</code> and <code>Le</code> implement <a href="../bitflags/traits/trait.Bits.html" title="trait bitflags::traits::Bits"><code>Bits</code></a>, <a href="../bitflags/parser/trait.ParseHex.html" title="trait bitflags::parser::ParseHex"><code>ParseHex</code></a>, and <a href="../bitflags/parser/trait.WriteHex.html" title="trait bitflags::parser::WriteHex"><code>WriteHex</code></a>.</li>
<li>[<code>bytemuck</code>] — <code>Be</code> and <code>Le</code> implement <a href="bytemuck::Zeroable"><code>Zeroable</code></a> and <a href="bytemuck::Pod"><code>Pod</code></a>.</li>
<li><code>linux-types</code> — Type aliases like in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/types.h?h=v6.9#n36"><code>linux/types.h</code></a>, such as <a href="type.le32.html" title="type endian_num::le32"><code>le32</code></a>.</li>
<li><a href="../zerocopy/index.html" title="mod zerocopy"><code>zerocopy</code></a> — <code>Be</code> and <code>Le</code> implement <a href="../zerocopy/trait.FromZeroes.html" title="trait zerocopy::FromZeroes"><code>FromZeroes</code></a>, <a href="../zerocopy/trait.FromBytes.html" title="trait zerocopy::FromBytes"><code>FromBytes</code></a>, and <a href="../zerocopy/trait.AsBytes.html" title="trait zerocopy::AsBytes"><code>AsBytes</code></a>.</li>
</ul>
<h2 id="related-crates"><a class="doc-anchor" href="#related-crates">§</a>Related crates</h2>
<ul>
<li><a href="https://docs.rs/endian-type">endian-type</a></li>
<li><a href="https://docs.rs/endian-type-rs">endian-type-rs</a> — Depends on <code>num</code>.</li>
<li><a href="https://docs.rs/endiantype">endiantype</a></li>
<li><a href="https://docs.rs/nora_endian">nora_endian</a></li>
<li><a href="https://docs.rs/simple_endian">simple_endian</a> — Also provides <code>f32</code>, <code>f64</code>, and <code>bool</code> types.</li>
<li><a href="https://docs.rs/zerocopy/0.7/zerocopy/byteorder/index.html"><code>zerocopy::byteorder</code></a> — These types are <a href="../zerocopy/trait.Unaligned.html" title="trait zerocopy::Unaligned"><code>Unaligned</code></a>, which makes them unsuitable for volatile memory operations.</li>
</ul>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Be.html" title="struct endian_num::Be">Be</a></div><div class="desc docblock-short">An integer stored in big-endian byte order.</div></li><li><div class="item-name"><a class="struct" href="struct.Le.html" title="struct endian_num::Le">Le</a></div><div class="desc docblock-short">An integer stored in little-endian byte order.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.be16.html" title="type endian_num::be16">be16</a></div><div class="desc docblock-short">A 16-bit unsigned integer stored in big-endian byte order.</div></li><li><div class="item-name"><a class="type" href="type.be32.html" title="type endian_num::be32">be32</a></div><div class="desc docblock-short">A 32-bit unsigned integer stored in big-endian byte order.</div></li><li><div class="item-name"><a class="type" href="type.be64.html" title="type endian_num::be64">be64</a></div><div class="desc docblock-short">A 64-bit unsigned integer stored in big-endian byte order.</div></li><li><div class="item-name"><a class="type" href="type.be128.html" title="type endian_num::be128">be128</a></div><div class="desc docblock-short">A 128-bit unsigned integer stored in big-endian byte order.</div></li><li><div class="item-name"><a class="type" href="type.le16.html" title="type endian_num::le16">le16</a></div><div class="desc docblock-short">A 16-bit unsigned integer stored in little-endian byte order.</div></li><li><div class="item-name"><a class="type" href="type.le32.html" title="type endian_num::le32">le32</a></div><div class="desc docblock-short">A 32-bit unsigned integer stored in little-endian byte order.</div></li><li><div class="item-name"><a class="type" href="type.le64.html" title="type endian_num::le64">le64</a></div><div class="desc docblock-short">A 64-bit unsigned integer stored in little-endian byte order.</div></li><li><div class="item-name"><a class="type" href="type.le128.html" title="type endian_num::le128">le128</a></div><div class="desc docblock-short">A 128-bit unsigned integer stored in little-endian byte order.</div></li></ul></section></div></main></body></html>