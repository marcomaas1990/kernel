searchState.loadedDescShard("multiboot", 0, "Multiboot v1 library\nThis module contains the pieces for parsing Multiboot …\nThis modules contains the pieces for parsing and creating …\nMultiboot struct bootloaders mainly interact with\nAddresses specified in the Multiboot header\nPreferred video mode specified in the Multiboot header\nPreferred video mode type\nCompute the offset of the load address into the binary.\nGet the preferred depth, if possible.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the header by parsing it from a slice.\nGet the load addresses specified in the Multiboot header.\nGet the preferred video mode specified in the Multiboot …\nIf true, then the <code>header_addr</code>, <code>load_addr</code>, <code>load_end_addr</code>, …\nIf true, then the <code>mode_type</code>, <code>width</code>, <code>height</code> and <code>depth</code> …\nthe index at which the header starts\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the preferred video mode type\nIf true, then the <code>header_addr</code>, <code>load_addr</code>, <code>load_end_addr</code>, …\nIf true, then the <code>mode_type</code>, <code>width</code>, <code>height</code> and <code>depth</code> …\nIf true, memory information must be passed.\nIf true, then the modules have to be page aligned.\nIf true, memory information must be passed.\nIf true, then the modules have to be page aligned.\nACPI Reclaim Memory\nMultiboot format for AOut Symbols\nmemory, available to OS\nThe ‘boot_device’ field.\nInformation for indexed color mode\nInformation for direct RGB color mode\nSafe wrapper for <code>ColorInfo</code>\ndefective RAM modules\nMultiboot format for ELF Symbols\nContains the information about the framebuffer\nMultiboot format of the MMAP buffer.\nImplement this trait to be able to get or set fields …\nUsed to iterate over all memory regions provided by …\nTypes that define if the memory is usable or not.\nInformation about a module in multiboot.\nUsed to iterate over all modules in multiboot.\nMultiboot struct clients mainly interact with\nRepresentation of Multiboot Information according to …\nACPI NVS Memory\nreserved, not available (rom, mem map dev)\nValue found in %eax after multiboot jumps to our entry …\nSafe wrapper for either <code>AOutSymbols</code> or <code>ElfSymbols</code>\nAllocates <code>length</code> bytes.\nGet base of memory region.\nIndicates which bios disk device the boot loader loaded …\nGet the name of the bootloader.\nGet the color info from this table.\nCommand line passed to the kernel.\nFree the previously allocated memory.\nGet the “default” memory entry. (It’s 0 bytes and …\nContains the bios drive number as understood by the bios …\nEnd address of module in physic memory.\nReturn end address of multiboot image.\nReturn the framebuffer table, if it exists.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nUses a passed address for the symbols.\nInitializes the multiboot structure from a passed address.\nInitializes this struct from an already existing …\nIf true, then the <code>syms</code> field is valid and contains AOut …\nIf true, then the <code>apm_table</code> field is valid.\nIf true, then the <code>boot_device</code> field is valid.\nIf true, then the <code>boot_loader_name</code> field is valid.\nIf true, then the <code>cmdline</code> field is valid.\nIf true, then the <code>config_table</code> field is valid.\nIf true, then the <code>drives_addr</code> and <code>drives_length</code> fields are …\nIf true, then the <code>syms</code> field is valid and containts ELF …\nIf true, then the framebuffer table is valid.\nIf true, then the <code>mem_upper</code> and <code>mem_lower</code> fields are valid.\nIf true, then the <code>mmap_addr</code> and <code>mmap_length</code> fields are …\nIf true, then the <code>mods_addr</code> and <code>mods_count</code> fields are …\nIf true, then the <code>vbe_*</code> fields are valid.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet size of the memory region.\nIndicate the amount of lower memory in kilobytes.\nDiscover all memory regions in the multiboot memory map.\nIs the region type valid RAM?\nDiscover all additional modules in multiboot.\nCreate a new entry from the given data.\nCreate this table from a color info.\nTranslates physical addr + size into a kernel accessible …\nSpecifies the top-level partition number.\nIs partition1 a valid partition?\nSpecifies a sub-partition in the top-level partition\nIs partition2 a valid partition?\nSpecifies a sub-partition in the 2nd-level partition\nIs partition3 a valid partition?\nSet the name of the bootloader.\nCommand line to be passed to the kernel.\nSet the framebuffer table, if it exists.\nIf true, then the <code>syms</code> field is valid and contains AOut …\nIf true, then the <code>apm_table</code> field is valid.\nIf true, then the <code>boot_device</code> field is valid.\nIf true, then the <code>boot_loader_name</code> field is valid.\nIf true, then the <code>cmdline</code> field is valid.\nIf true, then the <code>config_table</code> field is valid.\nIf true, then the <code>drives_addr</code> and <code>drives_length</code> fields are …\nIf true, then the <code>syms</code> field is valid and containts ELF …\nIf true, then the framebuffer table is valid.\nIf true, then the <code>mem_upper</code> and <code>mem_lower</code> fields are valid.\nIf true, then the <code>mmap_addr</code> and <code>mmap_length</code> fields are …\nIf true, then the <code>mods_addr</code> and <code>mods_count</code> fields are …\nIf true, then the <code>vbe_*</code> fields are valid.\nSets the memory bounds (lower, upper).\nPublish the memory regions to the kernel.\nPublish modules to the kernel.\nSet the symbols.\nStart address of module in physical memory.\nName of the module.\nGet the symbols.\nIndicate the amount of upper memory in kilobytes.")